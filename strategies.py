from hypothesis import strategies as st

#############################
### Some basic strategies ###
#############################

# There are many others.

## Generates True or False
# st.booleans()

## Generates None
# st.none()

## Generates datetimes (may be timezone-aware)
# st.datetimes()

## Generates a dictionary, with keys and values drawn from args
# st.dictionaries()

## Generates from a given sequence (enums, lists, etc)
# st.sampled_from()

"""
Note: You can look at examples of the data generated from each of 
these strategies interactively in a Python shell, by using .example()

>>> st.booleans().example() 
True
>>> st.booleans().example() 
False

See: https://hypothesis.readthedocs.io/en/latest/data.html
"""

##############################
### Working with timezones ###
##############################

## It's possible using the dateutil extension to specify that we
## only want to generate timezone-aware datetimes
## Requires pip install hypothesis[dateutil]

from hypothesis.extra.dateutil import timezones

## Generates a timezone-aware datetime
st.datetimes(timezones=timezones())


"""
Note: You can change many aspects of this strategy. You can limit
the timezones it generate, give it min and max datetimes, allow it to
generate imaginary datetimes that didn't occur or will not exist.
"""


############################
### Composite strategies ###
############################

## Suppose we wanted to write a hypothesis test that generated
## pairs of datetimes, but only if those datetimes met certain
## conditions (ISO 8601).

from hypothesis.strategies import composite
from hypothesis import assume


@composite
def compliant_datetime(draw):
    """
    Some datetimes generated by dateutil are not ISO 8601
    compliant, as the UTC-offsets for some timezones specify
    seconds (+HH:MM:SS rather than +HH:MM).

    Let's fix that with a composite strategy.
    """

    # A is drawn from the example database.
    A = draw(st.datetimes(timezones=timezones()))

    # Ensure that A does not contain seconds in its UTC offset
    assume(int(A.utcoffset().total_seconds() % 60) == 0)

    return A


###########################
### Extended strategies ###
###########################

## Now, suppose we wanted to create examples of valid and invalid
## instances of MyPydanticModel.


@composite
def valid_model(draw):
    """
    Generate valid model data.

    This will always generate a dictionary with the given keys,
    with values drawn from the provided strategies. You can give
    composite strategies to this composite strategy, combine and/or
    filter strategies, etc.
    """

    model_data = draw(
        st.fixed_dictionaries(
            {
                "name": st.sampled_from(["Jerry", "John", "James"]),
                "start": compliant_datetime(),
                "end": compliant_datetime(),
                "action": st.floats(allow_infinity=False, allow_nan=False),
            }
        )
    )

    ## Ensure start != end
    assume(model_data["start"] != model_data["end"])

    ## To satisfy our validators, swap start and end if required
    ## Try commenting-out this, or the above assume, and see what breaks.
    if model_data["start"] > model_data["end"]:
        model_data["start"], model_data["end"] = model_data["end"], model_data["start"]

    return model_data


@composite
def invalid_model(draw):
    """
    Generate invalid model data.

    This will generate a dictionary where some or all of the keys
    may be missing. If we wanted to be very technical, there is
    a small but non-zero chance that this will produce valid
    model data - in the real world, you would write more stringent
    assumptions into model generation, and more stringent test assertions.
    """

    # Anything which could be reasonably thought to be a name
    optional_name = draw(
        st.dictionaries(
            keys=st.just("name"),
            values=st.sampled_from(["Jerry", "John", "James"])
            | st.floats(allow_nan=True, allow_infinity=True)
            | st.text()
            | st.integers()
            | st.uuids(),
        )
    )

    # Anything which could be reasonably thought to be a start or end datetime.
    optional_datetimes = draw(
        st.dictionaries(
            keys=st.sampled_from(["start", "end"]),
            values=st.times() | st.dates() | st.datetimes() | st.timedeltas(),
        )
    )

    # Anything which could be reasonably thought to be an action
    optional_action = draw(
        st.dictionaries(
            keys=st.just("action"),
            values=st.floats(allow_nan=False, allow_infinity=False)
            | st.integers()
            | st.text(),
        )
    )

    return optional_name | optional_datetimes | optional_action
